# メモリシステム

N.E.K.O. のメモリシステムは、セッション間で永続的なコンテキストを提供し、キャラクターが過去の会話、ユーザーの好み、進化する関係性を記憶できるようにします。

## ストレージレイヤー

| レイヤー | ストレージ | 保持期間 | アクセスパターン |
|---------|-----------|---------|-----------------|
| **最近のメモリ** | JSONファイル（`recent_*.json`） | スライディングウィンドウ | 直接読み取り、キャラクターごと |
| **時間インデックス付きオリジナル** | SQLite（`time_indexed_original`） | 永続 | 時間範囲クエリ |
| **時間インデックス付き圧縮版** | SQLite（`time_indexed_compressed`） | 永続 | 時間範囲クエリ |
| **セマンティックメモリ** | ベクトルEmbedding（`text-embedding-v4`） | 永続 | 類似性検索 |

## メモリが会話に流れ込む仕組み

1. 新しいセッションが開始されると、システムは**最近のメモリ**（直近Nメッセージ）を即時コンテキストとして読み込みます。
2. **セマンティック検索**が、現在のトピックに基づいて関連する過去の会話を取得します。
3. **時間インデックス付きクエリ**が、時間的な参照（「昨日」「先週」）に対する時系列コンテキストを提供します。
4. 取得されたすべてのメモリは、コンテキストとしてLLMシステムプロンプトに注入されます。

## 圧縮パイプライン

古い会話はコンテキストウィンドウのスペースを節約するため、定期的に圧縮されます：

```
Raw conversation ──> Summary model (qwen-plus) ──> Compressed summary
                                                        │
                                                   time_indexed_compressed に保存
```

`ROUTER_MODEL`（デフォルト：`qwen-plus`）が、どのメモリを完全に保持するか、圧縮するかを決定します。

## メモリレビュー

ユーザーは `http://localhost:48911/memory_browser` で保存されたメモリを閲覧・修正できます。これは以下の問題に対処するのに役立ちます：

- 「メモリ」として保存されたモデルのハルシネーション
- キャラクターが内部化した不正確な事実
- 会話の要約における繰り返しパターン

## APIエンドポイント

完全なエンドポイントリファレンスについては、[メモリREST API](/api/rest/memory)を参照してください。

| エンドポイント | メソッド | 用途 |
|---------------|---------|------|
| `/api/memory/recent_files` | GET | すべてのメモリファイルを一覧表示 |
| `/api/memory/recent_file` | GET | 特定のメモリファイルの内容を取得 |
| `/api/memory/recent_file/save` | POST | 更新されたメモリを保存 |
| `/api/memory/update_catgirl_name` | POST | メモリ全体でキャラクター名を変更 |
| `/api/memory/review_config` | GET/POST | メモリレビュー設定 |
